## 参考 [https://www.soldev.app/course](https://www.soldev.app/course) 的实现

### 1. 第一个模块完成了，做一下相应的总结。

+ solana使用密钥来保存账户信息，公钥代表账户名称，私钥代表账户凭据。公钥其他人都可以看到，私钥需要自己保存好，是唯一账户账户所有权的东西，丢失就代表找回不了自己账户。

+ 因为区块链是公开的，公钥也是公开的。因此可以通过网络轻易的查询出自己公钥所拥有的信息。

+ solana写入数据是通过交易(transaction)实现的。交易是有一条条指令(instruction)组成的. 指令三要素为程序入口(程序公钥地址), 操作账户信息(操作账户公钥，是否签名地址，是否可写入)及指令数据(可为空)。

+ 交易在发送给solana处理时，需添加私钥签名。通常，不应该将私钥直接在代码中调用，可以使用solana钱包暴露出的方法来发送交易。(phantom钱包即暴露出sendTransaction方法)

+ 指令数据可使用borsh进行序列化/反序列化操作。u8,u64,u32,bool等类型是有固定长度的。字符串是非定长的，但是字符串的前4位存储的str长度。

+ 程序存储的数据是存放在派生地址(PDA, Program Derived Address). 可通过findProgramAddress方法通过程序公钥获取派生地址，从而存储相应数据。

+ 可通过方法getProgramAccounts获取成勋对应的所有派生地址及其存储的数据。同时也可以通过memcmp进行相应的筛选，筛选时是通过字节数据进行前缀模糊搜索的，因此一定要确定的获取查询字段在数据中的偏移数据量。(borsh序列化数据时，似乎所有确定长度的字段排序在前面，其他字段在后面。)

+ 筛选后的数据因为进行过了截取，因此需要根据获取到的派生地址重新调用getMultipleAccountsInfo获取详细数据，然后进行反序列化，此时就可以得到序列化之前的数据。